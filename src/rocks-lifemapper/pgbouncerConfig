#!/usr/bin/env python

import os
import stat
import sys
import glob
import subprocess
import shutil
import time
import pgconstants
from pprint import pprint


class PGbouncer:
    def __init__(self, argv):
        self.args = argv[1:]
        self.ip            = None                           # host ip on public interface
        self.network       = None                           # host network 
        self.cidr          = None                           # host CIDR 
        self.pgbconf       = pgconstants.PGBINI             # pgbouncer config file
        self.pgbtempl      = pgconstants.PGBTEMPL           # pgbouncer config file template
        self.authFile      = pgconstants.PGBAUTH            # pgbouncer auth file
        self.users         = pgconstants.USERS_FILE         # users file
        self.unixSocketDir = pgconstants.UNIX_SOCKET_DIR    # unix socket dir for postgres 
        self.userlist      = pgconstants.USERS_LIST         # pgbouncer users
        self.time          = None                           # time stamp of running the script

        self.findTime()
        self.getNetworkInfo()

    def findTime(self):
        """ create a time stamp of running the script. 
            Time stamp is used as a  suffix for saved files """
        secs = time.time()
        tuple = time.localtime(secs)
        self.time = ".%s" % time.strftime("%Y%m%d-%H%M", tuple)

    def getNetworkInfo(self):
        """ find host network info for public interface """
        cmd = "rocks list host attr localhost | grep Kickstart_Public"
        info, err = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        lines = info.split("\n")
        for line in lines:
            if len(line):
                parts = line.split()
                if parts[1]  == "Kickstart_PublicAddress": self.ip = parts[2]
                if parts[1]  == "Kickstart_PublicNetwork": self.network = parts[2]
                if parts[1]  == "Kickstart_PublicNetmaskCIDR": self.cidr = parts[2]

        if self.ip == None or self.network == None or self.cidr == None:
            print "Missing information about public interface "
            sys.exit(1)

    def getPerms(self, config):
        """ find permissions and ownership for the config file """
        stats = os.stat(config)
        self.uid = stats[stat.ST_UID]
        self.gid = stats[stat.ST_GID]

    def readFile(self, fname):
        """ read file, return content"""
        try: 
            fin = open(fname, "r")
            lines = fin.readlines()
            fin.close()
        except IOError as e:
            print "ERROR: ", e.strerror, "%s" % fname
            sys.exit(1)
        return lines

    def writeFile(self, fname, content):
        """ write file """
        try:
            fout = open(fname, "w")
            fout.write(content)
            fout.close()
            print "Created %s file" % fname
        except IOError as e:
            print "ERROR: ", e.strerror, "%s" % fname
            sys.exit(1)

    def makeConfigFile(self):
        """ create new pgbouncer.ini file """

        # make a copy of orig file, use original ownership and permissions
        fname = self.pgbconf 
        fcopy = fname + self.time
        fcopy = "/tmp/" + os.path.basename(fname) + self.time  #FIXME rm
        self.getPerms(fname)
        shutil.copy2(fname, fcopy)
        os.chown(fcopy, self.uid, self.gid)
        print "Original %s is backed up as %s " % (fname, fcopy)

        # create config file template if does not exist (1st time run)
        templ = self.pgbtempl
        if not os.path.isfile(templ):
            shutil.copy2(fname, templ)
            os.chown(templ, self.uid, self.gid)
            print "Created template %s " % (templ)

        # read defaults from original file
        content = self.readFile(templ)
        defaultLines = self.defaultConfig(content)

        # create new config file, set original ownership and permissions
        newLines = self.makePGBlines()
        fnew = fname
        fnew = "/tmp/" + os.path.basename(fname)  #FIXME rm

        self.writeFile(fnew, defaultLines + newLines)
        shutil.copymode(fname, fnew)
        os.chown(fnew, self.uid, self.gid)

        
    def defaultConfig(self, lines):
        """ read original pgbouncer.ini content, skip lines to be overwritten, return non-comment lines """

        comments = [";", " ", "\t", "\n"]
        keywords = ["logfile", "pidfile", "auth_file", "listen_port", "pool_mode" ]
        content = ""
        for line in lines:
            if line[0] in comments:
                continue
            if line.split()[0] in keywords: 
                content += line

        return content

    def makePGBlines(self):
        """ create lines to add to pgbouncer.ini configuration file """
        addLines = ";; Specific to Lifemapper\n"
        addLines += "[databases]\n"
        addLines += "* = host=%s\n\n" % self.ip
        addLines += ";; Configuration section\n"
        addLines += "[pgbouncer]\n\n"
        addLines += "listen_addr = %s/%s\n" % (self.network, self.cidr)
        addLines += "unix_socket_dir  = %s\n" % self.unixSocketDir
        addLines += "auth_type = md5\n"
        addLines += "auth_file = /etc/pgbouncer/userlist.txt\n"
        addLines += "admin_users =\n"
        addLines += "stats_users =\n"

        return addLines        

    def makeAuthLines(self):
        """ create lines for auth file """
        import hashlib
        key_string = "SecretPassword"
        salt = "1Ha7"
        hash = hashlib.md5( salt + key_string ).hexdigest()

        # read user/pass list 
        lines = ""
        content = self.readFile(self.users)
        for item in content:
            user, unencPasswd = item.split()
            encPasswd = hashlib.md5(unencPasswd).hexdigest()
            lines += "\"%s\" \"%s\"\n" % (user, encPasswd)

        return lines

    def makeAuthFile(self):
        """ create pgbouncer authentication userlist.txt file """

        # find owner permissiosn on unix socket dir
        self.getPerms(self.unixSocketDir)

        # create auth file content
        lines = self.makeAuthLines()

        # write auth file
        fnew = self.authFile
        fnew = "/tmp/" + os.path.basename(self.authFile)  #FIXME rm
        self.writeFile(fnew, lines)
        os.chmod(fnew, 0600)
        os.chown(fnew, self.uid, self.gid)

    def runTest(self):
        """ test output """
        pprint (self.__dict__)

    def run(self):
        self.makeConfigFile()
        self.makeAuthFile()

if __name__ == "__main__":
        app=PGbouncer(sys.argv)
        app.run()

